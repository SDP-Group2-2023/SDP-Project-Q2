struct Edge{
    Node* node1;
    Node* node2;
    int weight;
}

struct Node{
    int id;
    Node* parent1;
    Node* parent2;
    Node* child;
    int weight;
    vector<Edge*> edges;
}

class Graph{
    vector<Node*> nodes;
    int V;
    int E;
}



main():
    case 1:
        path = input("Enter the path of the file: ")
        Graph g = loadGraphFromFile(path)
    case 2:
        num_partition = input("Enter the number of partitions: ")
        partition_vector = g.sequentialPartition(num_partition);
    case 3:
        num_partition = input("Enter the number of partitions: ")
        num_thread = input("Enter the number of threads: ")
        partition_vector = g.parallelPartition(num_partition, num_thread);
    case 4:
        num_partition = input("Enter the number of partitions: ")
        partition_vector_sequential = g.sequentialPartition(num_partition);
        for(i = 0; i<MAX_THREAD; i++)
            partition_vector_parallel = g.parallelPartition(num_partition, i);
    case 5:
        free memory
        exit


sequentialPartition(num_partition):

    actual_num_partition = g.V;
    iteration = 0;
    while(iteration < MAX_ITERATION || actual_num_partition > num_partition * 15):
        Grapg coarsedGraph = coarsen(g);
        actual_num_partition = coarsedGraph.V;
        iteration++;

    Graph partitionedGraph = partition(coarsedGraph, num_partition);

    for(i = 0; i < iteration; i++):
        Graph recostructedGraph = reconstruct(partitionedGraph);
        partitionedGraph = refine(recostructedGraph);

    return partitionedGraph.partitions();


refine(recostructedGraph):
    refinedGraph = kerniganLin(recostructedGraph);
    return refinedGraph;

coarsen(graph):

    Graph coarsedGraph;
    int index = 0;
    vector<bool> matchedNodes(graph.V, false);
    vector<Edge*> unmatchedEdges;

    //creazione dei nuovi nodi
    orderedNodes = sortByWeight(graph.nodes);
    for(n : orderedNodes):
        bool flag = false;
        for(e : n.edges):
            if(!matchedNodes[e.node1.id] && !matchedNodes[e.node2.id]):
                Node n1 = e.node1;
                Node n2 = e.node2;
                Node* newNode = new Node(index, n1, n2, n1.weight + n2.weight);
                n1.child = newNode;
                n2.child = newNode;
                coarsedGraph.nodes.push_back(newNode);
                matchedNodes[e.node1.id] = true;
                matchedNodes[e.node2.id] = true;
                flag = true;
                index++;
            else{
                unmatchedEdges.push_back(e);
            }
        if(!flag){
            Node* newNode = new Node(index, n, NULL, n.weight);
            coarsedGraph.nodes.push_back(newNode);
            index++;
        }

    for(e: unmatchedEdge):
        coarsedGraph.addOrSumEdge(e.node1.child, e.node2.child, e.weight);

    return coarsedGraph;

